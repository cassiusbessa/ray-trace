## ðŸ“¦ Estrutura do Projeto

```
raytracer_c/
â”œâ”€â”€ include/
â”‚   â”œâ”€â”€ minilibx/
â”‚   â””â”€â”€ miniRT.h                    # Headers gerais e structs compartilhados
â”‚
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ camera/                     # Gerenciamento da cÃ¢mera e geraÃ§Ã£o de raios
â”‚   â”‚   â”œâ”€â”€ camera_utils.c          # FunÃ§Ãµes utilitÃ¡rias para cÃ¢mera
â”‚   â”‚   â”œâ”€â”€ ray_for_pixel.c         # FunÃ§Ã£o ray_for_pixel()
â”‚   â”‚   â””â”€â”€ render.c                # FunÃ§Ã£o render() que gera a imagem
â”‚
â”‚   â”œâ”€â”€ canvas/                     # ManipulaÃ§Ã£o de canvas, pixels e exportaÃ§Ã£o de imagem
â”‚   â”‚   â”œâ”€â”€ canvas.c                # CriaÃ§Ã£o de canvas, escrita de pixels
â”‚   â”‚   â”œâ”€â”€ canvas_export.c         # ExportaÃ§Ã£o para .ppm, clamp de cores
â”‚   â”‚   â””â”€â”€ canvas_utils.c          # FunÃ§Ãµes auxiliares para canvas
â”‚
â”‚   â”œâ”€â”€ color/                      # OperaÃ§Ãµes com cores
â”‚   â”‚   â”œâ”€â”€ color_utils_1.c         # CriaÃ§Ã£o e operaÃ§Ãµes bÃ¡sicas (add, subtract)
â”‚   â”‚   â””â”€â”€ color_utils_2.c         # MultiplicaÃ§Ã£o, produto Hadamard, clamp
â”‚
â”‚   â”œâ”€â”€ geometry/                   # InterseÃ§Ãµes e normais de objetos geomÃ©tricos
â”‚   â”‚   â”œâ”€â”€ intersect_cylinder.c    # Cilindro: interseÃ§Ã£o, tampas, normal
â”‚   â”‚   â””â”€â”€ intersect_plane.c       # Plano: interseÃ§Ã£o e normal
â”‚
â”‚   â”œâ”€â”€ graphics/                   # IntegraÃ§Ã£o com MiniLibX e renderizaÃ§Ã£o final
â”‚   â”‚   â”œâ”€â”€ mlx_hooks.c             # Eventos e hooks MLX (teclado, mouse)
â”‚   â”‚   â”œâ”€â”€ mlx_render.c            # RenderizaÃ§Ã£o usando MLX
â”‚   â”‚   â””â”€â”€ mlx_setup.c             # Setup da janela e imagem MLX
â”‚
â”‚   â”œâ”€â”€ lighting/                   # Luzes, materiais e cÃ¡lculo de iluminaÃ§Ã£o
â”‚   â”‚   â”œâ”€â”€ default_material.c      # Materiais padrÃ£o e propriedades
â”‚   â”‚   â”œâ”€â”€ lighting.c              # CÃ¡lculo de iluminaÃ§Ã£o e sombras
â”‚   â”‚   â”œâ”€â”€ point_light.c           # Luz pontual
â”‚   â”‚   â””â”€â”€ ray_tracer_core.c       # NÃºcleo do ray tracer: shade_hit, color_at, etc.
â”‚
â”‚   â”œâ”€â”€ matrix/                     # Matrizes e operaÃ§Ãµes relacionadas
â”‚   â”‚   â”œâ”€â”€ matrix_core.c           # CriaÃ§Ã£o, identidade, print, free
â”‚   â”‚   â”œâ”€â”€ matrix_determinant.c    # Determinantes, cofatores, invertibilidade
â”‚   â”‚   â”œâ”€â”€ matrix_inverse.c        # CÃ¡lculo de matriz inversa
â”‚   â”‚   â””â”€â”€ matrix_math.c           # MultiplicaÃ§Ã£o e operaÃ§Ãµes auxiliares
â”‚
â”‚   â”œâ”€â”€ parser/                     # Parsing do arquivo .rt e validaÃ§Ãµes
â”‚   â”‚   â”œâ”€â”€ parse_ambient.c         # Parser de luz ambiente (A)
â”‚   â”‚   â”œâ”€â”€ parse_camera.c          # Parser de cÃ¢mera (C)
â”‚   â”‚   â”œâ”€â”€ parse_cylinder.c        # Parser de cilindro (cy)
â”‚   â”‚   â”œâ”€â”€ parse_light.c           # Parser de luz pontual (L)
â”‚   â”‚   â”œâ”€â”€ parse_plane.c           # Parser de plano (pl)
â”‚   â”‚   â”œâ”€â”€ parse_sphere.c          # Parser de esfera (sp)
â”‚   â”‚   â”œâ”€â”€ parser.c                # FunÃ§Ã£o principal do parser
â”‚   â”‚   â”œâ”€â”€ parser.h                # Prototypes e structs do parser
â”‚   â”‚   â”œâ”€â”€ parser_utils_1.c        # Auxiliares (split, validaÃ§Ãµes iniciais)
â”‚   â”‚   â””â”€â”€ parser_utils_2.c        # Auxiliares (validaÃ§Ã£o avanÃ§ada, conversÃµes)
â”‚
â”‚   â”œâ”€â”€ ray/                        # Raios e interseÃ§Ãµes
â”‚   â”‚   â”œâ”€â”€ intersection.c          # InterseÃ§Ãµes, hits, preparaÃ§Ã£o computacional
â”‚   â”‚   â”œâ”€â”€ ray.c                   # CriaÃ§Ã£o e manipulaÃ§Ã£o de raios
â”‚   â”‚   â”œâ”€â”€ sphere.c                # Esfera e suas transformaÃ§Ãµes
â”‚   â”‚   â””â”€â”€ world.c                 # Mundo da cena, interseÃ§Ã£o global e iluminaÃ§Ã£o
â”‚
â”‚   â”œâ”€â”€ transformations/            # TransformaÃ§Ãµes geomÃ©tricas (translate, rotate, scale)
â”‚   â”‚   â”œâ”€â”€ rotation.c              # rotaÃ§Ãµes nos eixos X, Y, Z
â”‚   â”‚   â”œâ”€â”€ shearing.c              # cisalhamento
â”‚   â”‚   â””â”€â”€ translation_scaling.c   # translaÃ§Ã£o e escala
â”‚
â”‚   â”œâ”€â”€ tuple/                      # Tuplas e vetores (nÃºcleo e operaÃ§Ãµes matemÃ¡ticas)
â”‚   â”‚   â”œâ”€â”€ tuple_core.c            # CriaÃ§Ã£o de tuplas, pontos e vetores
â”‚   â”‚   â”œâ”€â”€ tuple_math.c            # OperaÃ§Ãµes bÃ¡sicas: add, sub, mult, div
â”‚   â”‚   â”œâ”€â”€ tuple_utils.c           # ComparaÃ§Ãµes, validaÃ§Ãµes, propriedades
â”‚   â”‚   â””â”€â”€ tuple_vector.c          # magnitude, normalizaÃ§Ã£o, produto escalar e vetorial
â”‚
â”œâ”€â”€ utils/                          # UtilitÃ¡rios diversos
â”‚   â””â”€â”€ libft/                      # Biblioteca Libft customizada
â”‚       â”œâ”€â”€ ft_atoi.c
â”‚       â”œâ”€â”€ ft_bzero.c
â”‚       â”œâ”€â”€ ft_calloc.c
â”‚       â”œâ”€â”€ ...                     # demais arquivos da libft
â”‚       â”œâ”€â”€ Makefile                # Makefile da libft
â”‚       â””â”€â”€ libft.h                 # Header da libft
â”œâ”€â”€â”€â”€ Main.c                        # main para rodar o programa
â”‚
â”œâ”€â”€â”€â”€ Makefile                      # Build system principal
â””â”€â”€ README.md


```
===========================
FunÃ§Ãµes por Arquivo
===========================
// ----------------------
// Tuple functions
// ----------------------

t_tuple		new_tuple(float x, float y, float z, t_bool is_point);
t_tuple		point_tuple(float x, float y, float z);
t_tuple		vector_tuple(float x, float y, float z);

t_tuple		add_tuple(t_tuple t1, t_tuple t2);
t_tuple		subtract_tuple(t_tuple t1, t_tuple t2);
t_tuple		negate_tuple(t_tuple t);
t_tuple		multiply_tuple(t_tuple t, float scalar);
t_tuple		divide_tuple(t_tuple t, float scalar);

float		magnitude_vector(t_tuple t);
t_tuple		normalize_vector(t_tuple t);
float		vector_dot(t_tuple t1, t_tuple t2);
t_tuple		vector_cross(t_tuple t1, t_tuple t2);

int			tuple_equal(t_tuple t1, t_tuple t2);
int			is_point(t_tuple t);
int			is_vector(t_tuple t);

// Auxiliares para acessar valores
double		get_tuple_value(t_tuple t, int index);
void		set_tuple_value(t_tuple *t, int index, double value);


// ----------------------
// Matrix functions
// ----------------------

t_matrix	new_matrix(int rows, int cols);
t_matrix	identity_matrix(int size);

t_matrix	matrix_multiply_by_matrix(t_matrix a, t_matrix b);
t_tuple		matrix_multiply_by_tuple(t_matrix m, t_tuple t);

t_matrix	transpose_matrix(t_matrix m);
t_matrix	submatrix(t_matrix m, int row, int col);

int			matrix_determinant(t_matrix m);
int			matrix_determinant_2x2(t_matrix m);
int			matrix_minor(t_matrix m, int row, int col);
int			matrix_cofactor(t_matrix m, int row, int col);
int			matrix_is_invertible(t_matrix m);

t_matrix	matrix_inverse(t_matrix m);

void		print_matrix(t_matrix m);
void		free_matrix(t_matrix m);


// ----------------------
// Transformations
// ----------------------

t_matrix	translation_matrix(float tx, float ty, float tz);
t_matrix	scaling_matrix(float sx, float sy, float sz);
t_matrix	rotation_x(float radians);
t_matrix	rotation_y(float radians);
t_matrix	rotation_z(float radians);
t_matrix	shearing(float xy, float xz, float yx, float yz, float zx, float zy);

t_matrix	view_transform(t_tuple from, t_tuple to, t_tuple up);
t_matrix	multiply_transform_chain(t_matrix *transforms, int count);


// ----------------------
// Ray functions
// ----------------------

t_ray		create_ray(t_tuple origin, t_tuple direction);
t_tuple		ray_position(t_ray ray, float t);
t_ray		transform_ray(t_ray ray, t_matrix transform);


// ----------------------
// Sphere functions
// ----------------------

t_sphere	create_sphere(void);
void		set_transform_sphere(t_sphere *sphere, t_matrix transform);
t_matrix	get_transform_sphere(t_sphere sphere);
t_sphere	default_sphere(void);


// ----------------------
// Intersection functions
// ----------------------

t_intersection	*intersect_sphere(t_sphere *sphere, t_ray ray, int *count);
t_intersection	*hit(t_intersection *intersections, int count);

int				compare_intersections(const void *a, const void *b);

t_intersection	*resize_intersections(t_intersection *arr, int *capacity);
int				append_intersections(t_intersection **dst, int *total_count, int *capacity, t_intersection *src, int src_count);

t_intersection	*intersect_world(t_world *world, t_ray ray, int *count);


// ----------------------
// Light and Material functions
// ----------------------

t_light		point_light(t_tuple position, t_color intensity);

t_material	default_material(void);
void		set_material_props(t_material *material, ...);

t_color		lighting(t_material_light_params mlp, t_lighting_context ctx);
t_color		calculate_diffuse(t_material material, t_color effective_color, float light_dot_normal);
t_color		calculate_specular(t_material material, t_light light, t_tuple reflectv, t_tuple eyev);


// ----------------------
// Color functions
// ----------------------

t_color		create_color(float r, float g, float b);
t_color		add_color(t_color c1, t_color c2);
t_color		subtract_color(t_color c1, t_color c2);
t_color		multiply_color_scalar(t_color c, float scalar);
t_color		multiply_color(t_color c1, t_color c2);

int			color_equal(t_color c1, t_color c2);


// ----------------------
// Canvas functions
// ----------------------

t_canvas	*new_canvas(int width, int height);
void		free_canvas(t_canvas *canvas);

void		write_pixel(t_canvas *canvas, int x, int y, t_rgb color);
t_rgb		*pixel_at(t_canvas *canvas, int x, int y);

void		fill_black_canvas(t_canvas *canvas);
int			clamp(float value);

void		canvas_to_ppm(t_canvas *canvas, const char *filename);


// ----------------------
// Camera functions
// ----------------------

t_ray		ray_for_pixel(t_camera camera, int px, int py);
void		render(t_camera camera, t_world world, t_canvas *canvas);


// ----------------------
// Ray tracing core functions
// ----------------------

t_color		shade_hit(t_world *world, t_intersection *hit, t_ray ray);
t_color		color_at(t_world *world, t_ray ray);
t_tuple		compute_normal(t_object *object, t_tuple point);
int			is_shadowed(t_world *world, t_tuple point);


// ----------------------
// Parser functions
// ----------------------

int			parse_rt_file(const char *filename, t_world *world);

int			parse_ambient(const char *line, t_world *world);
int			parse_camera(const char *line, t_world *world);
int			parse_light(const char *line, t_world *world);

int			parse_sphere(const char *line, t_world *world);
int			parse_plane(const char *line, t_world *world);
int			parse_cylinder(const char *line, t_world *world);

int			line_is_empty_or_comment(const char *line);
int			starts_with(const char *line, const char *prefix);

void		free_split(char **tokens);
void		print_error(const char *msg);

void		free_parsed_world(t_world *world, int should_free_world);

int			parse_vector(const char *str, t_tuple *out_vector);
int			parse_point(const char *str, t_tuple *point);
int			parse_color(const char *str, t_color *out_color);

int			is_normalized(t_tuple vector);

void		add_object_to_world(t_world *world, t_object *new_object);

t_object	*new_cylinder(t_tuple position, t_tuple orientation, float diameter, float height, t_color color);
t_object	*create_sphere(t_tuple position, float diameter, t_color color);
t_object	*create_plane(t_tuple position, t_tuple orientation, t_color color);

double		ft_atod(const char *str);
float		deg_to_rad(float degrees);


// ----------------------
// Geometry functions
// ----------------------

t_roots		solve_quadratic(float a, float b, float c);

int			is_within_cylinder_height(t_tuple point, t_cylinder cylinder, t_tuple axis);

float		intersect_cylinder(t_ray ray, t_cylinder cylinder);
static float	intersect_disk(t_ray ray, t_tuple center, t_tuple axis, float radius);
static float	hit_caps(t_ray ray, t_cylinder cylinder);

float		cylinder_intersect(t_ray ray, t_cylinder cylinder);
t_tuple		get_normal_cylinder(t_cylinder cylinder, t_tuple point);

t_vector	get_normal_plane(t_plane plane);


// ----------------------
// Graphics (MiniLibX)
// ----------------------

t_mlx		init_window(int width, int height, char *title);
void		run_mlx(t_mlx *mlx, t_canvas *canvas);
void		draw_canvas_to_image(t_canvas *canvas, t_img *img);

int			handle_keypress(int keycode, t_mlx *mlx);
int			handle_close(t_mlx *mlx);
int			handle_mouse_close(int button, int x, int y, t_mlx *mlx);

---

## ðŸ”¨ CompilaÃ§Ã£o (Makefile)
```makefile
CC=gcc
CFLAGS=-Wall -Wextra -Iinclude
SRC=$(wildcard src/*.c)
OBJ=$(SRC:.c=.o)
EXEC=raytracer

default: $(EXEC)

$(EXEC): $(OBJ)
	$(CC) $(CFLAGS) -o $@ $^

clean:
	rm -f $(OBJ) $(EXEC)
```

---

===========================
Sprints de Desenvolvimento
===========================

---------------------------
Sprint 1: Tuplas e Vetores
---------------------------
- Implementar tuple.h/c:
    - FunÃ§Ãµes: point(), vector(), add(), sub(), negate(), scale()
               magnitude(), normalize(), dot(), cross()
- Criar testes com assert em test_runner.c

------------------------------
Sprint 2: Matrizes 4x4
------------------------------
- Implementar matrix.h/c:
    - FunÃ§Ãµes: identidade, multiplicaÃ§Ã£o, submatriz, cofator,
               determinante, inversa
    - MultiplicaÃ§Ã£o matriz Ã— tupla
- Criar testes para inversa e determinante

----------------------------------
Sprint 3: TransformaÃ§Ãµes
----------------------------------
- Implementar transforms.h/c:
    - FunÃ§Ãµes: translation, scaling, rotation_x, rotation_y,
               rotation_z, shearing
- Criar funÃ§Ã£o: multiply_transform_chain()
- Testar transformaÃ§Ãµes aplicadas em tuplas

-----------------------------------------
Sprint 4: Raios e InterseÃ§Ãµes
-----------------------------------------
- Implementar ray.h/c:
    - Criar raio, calcular ponto ao longo do raio (position)
- Implementar sphere.h/c:
    - Criar esfera, aplicar transformaÃ§Ãµes
- Implementar intersection.h/c:
    - FunÃ§Ãµes: intersect(), hit()

--------------------------------------
Sprint 5: Luz e Materiais
--------------------------------------
- Implementar light.h/c:
    - FunÃ§Ã£o: point_light
- Implementar material.h/c:
    - Propriedades: cor base, difuso, especular, shininess
- Implementar funÃ§Ã£o: lighting() (modelo Phong)

---------------------------------------
Sprint 6: CÃ¢mera e Canvas
---------------------------------------
- Implementar camera.h/c:
    - FunÃ§Ãµes: ray_for_pixel(), render()
- Implementar canvas.h/c:
    - Estrutura de pixels, exportaÃ§Ã£o .ppm
- Testar renderizaÃ§Ã£o de imagem simples

-----------------------------------------------------------
Sprint 7: Parser do Arquivo .rt e Estrutura de Cena (world)
-----------------------------------------------------------
- Implementar parser do arquivo .rt para:
    - Ambient (A)
    - Camera (C)
    - Light (L)
    - Objetos: Sphere (sp), Plane (pl), Cylinder (cy)
- Criar structs da cena (t_world):
    - Listas/arrays de objetos e luzes
- Validar e tratar erros do .rt:
    - Formato invÃ¡lido, valores fora do padrÃ£o
- Testar leitura de arquivos .rt reais

------------------------------------------------------
Sprint 8: Plano e Cilindro (Geometria AvanÃ§ada)
------------------------------------------------------
- Implementar interseÃ§Ã£o para Plano (pl)
- Implementar interseÃ§Ã£o e normais para Cilindro (cy):
    - Considerar altura, raio, tampas
- Suportar transformaÃ§Ãµes em todos os objetos
- Testar interseÃ§Ãµes e normais, inclusive internas

-----------------------------------------------
Sprint 9: IluminaÃ§Ã£o Completa e Sombras
-----------------------------------------------
- Completar modelo de iluminaÃ§Ã£o:
    - ambient, diffuse, specular
- Implementar detecÃ§Ã£o de sombras duras: is_shadowed()
- Aplicar sombras na renderizaÃ§Ã£o
- Testar configuraÃ§Ãµes variadas de luz e materiais

------------------------------------------------------
Sprint 10: IntegraÃ§Ã£o com MiniLibX (Janela GrÃ¡fica)
------------------------------------------------------
- Criar structs t_mlx e t_img
- Implementar conversÃ£o do canvas para imagem MLX
- Criar e exibir janela com MiniLibX
- Adicionar eventos:
    - Fechar com ESC ou botÃ£o de janela
- Garantir responsividade:
    - Minimizar, foco etc.
- Testar renderizaÃ§Ã£o final na janela interativa

---


Se quiser, posso continuar agora com o------------------------------------------------------
Sprint 10: IntegraÃ§Ã£o com MiniLibX (Janela GrÃ¡fica)
------------------------------------------------------
- Criar structs t_mlx e t_img
- Implementar conversÃ£o do canvas para imagem MLX
- Criar e exibir janela com MiniLibX
- Adicionar eventos:
    - Fechar com ESC ou botÃ£o de janela
- Garantir responsividade:
    - Minimizar, foco etc.
- Testar renderizaÃ§Ã£o final na janela interativa

 
 
 Quero que eu avance com isso porem desejo que voc crie uma forma de me explicar com detalhes e me ensinar o que eu estou fazendo, se preocupe por cada detalhe e cada instruÃ§Ã£o na sprint 9, use todo conhecimento acima para conseguir essa tarefa
