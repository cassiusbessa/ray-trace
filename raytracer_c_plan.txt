# ðŸŽ¯ Projeto: Ray Tracer em C (baseado em "The Ray Tracer Challenge" + minirt da Ecole 42)

---

## ðŸ“¦ Estrutura do Projeto

```

raytracer_c/
â”œâ”€â”€ include/
â”‚   â””â”€â”€ miniRT.h
â”‚
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ tuple/
â”‚   â”‚   â”œâ”€â”€ tuple_core.c          # create_tuple, point, vector, color, is_point/is_vector
â”‚   â”‚   â”œâ”€â”€ tuple_math.c          # add_tuples, subtract_tuples, negate_tuple, multiply_tuple, divide_tuple
â”‚   â”‚   â”œâ”€â”€ tuple_vector.c        # magnitude, normalize, dot, cross
â”‚   â”‚   â””â”€â”€ tuple_utils.c         # equal_tuples, is_zero_vector, is_unit_vector, is_nan, is_finite
â”‚   â”‚
â”‚   â”œâ”€â”€ matrix/
â”‚   â”‚   â”œâ”€â”€ matrix_core.c         # new_matrix, identity_matrix, free_matrix, print_matrix, equal_matrix
â”‚   â”‚   â”œâ”€â”€ matrix_math.c         # matrix_multiply_by_matrix, matrix_multiply_by_tuple, transpose_matrix, submatrix, minor
â”‚   â”‚   â”œâ”€â”€ matrix_determinant.c  # matrix_determinant, matrix_determinant_2x2, matrix_cofactor, matrix_is_invertible
â”‚   â”‚   â””â”€â”€ matrix_inverse.c      # matrix_inverse
â”‚   â”‚
â”‚   â”œâ”€â”€ transformations/
â”‚   â”‚   â”œâ”€â”€ translation_scaling.c # translation, scaling
â”‚   â”‚   â”œâ”€â”€ rotation.c            # rotation_x, rotation_y, rotation_z
â”‚   â”‚   â””â”€â”€ shearing.c            # shearing
â”‚   â”‚
â”‚   â”œâ”€â”€ ray/
â”‚   â”‚   â”œâ”€â”€ ray.c                 # create_ray, ray_position, transform_ray
â”‚   â”‚   â”œâ”€â”€ sphere.c              # create_sphere, set_transform, get_transform, default_sphere
â”‚   â”‚   â””â”€â”€ intersection.c        # create_intersection, intersect, hit, prepare_computations, compare_intersections, resize_intersections, append_intersections, intersect_world
â”‚   â”‚
â”‚   â”œâ”€â”€ lighting/
â”‚   â”‚   â”œâ”€â”€ point_light.c         # create_point_light
â”‚   â”‚   â”œâ”€â”€ default_material.c    # default_material, set_material_props
â”‚   â”‚   â”œâ”€â”€ ray_tracer_core.c     # shade_hit, color_at, compute_normal, is_shadowed
â”‚   â”‚   â””â”€â”€ lighting.c            # lighting_calculation, is_shadowed, reflect
â”‚   â”‚
â”‚   â”œâ”€â”€ color/
â”‚   â”‚   â”œâ”€â”€ color_utils_1.c       # create_color, color_add, color_subtract
â”‚   â”‚   â””â”€â”€ color_utils_2.c       # color_multiply, hadamard_product, clamp_color
â”‚   â”‚
â”‚   â”œâ”€â”€ camera/                   # Tudo relacionado a gerar raios e manipular a cÃ¢mera
â”‚   â”‚   â”œâ”€â”€ ray_for_pixel.c       # FunÃ§Ã£o ray_for_pixel
â”‚   â”‚   â”œâ”€â”€ render.c              # FunÃ§Ã£o render (usa ray_for_pixel)
â”‚   â”‚   â””â”€â”€ camera_utils.c        # Futuras utilidades da cÃ¢mera
â”‚   â”‚
â”‚   â”œâ”€â”€ canvas/                   # Tudo sobre imagem, pixels e exportaÃ§Ã£o
â”‚   â”‚   â”œâ”€â”€ canvas.c              # create_canvas, write_pixel
â”‚   â”‚   â”œâ”€â”€ canvas_export.c       # canvas_to_ppm, clamp
â”‚   â”‚   â””â”€â”€ canvas_utils.c        # FunÃ§Ãµes auxiliares para canvas
â”‚   â”‚
â”‚   â”œâ”€â”€ parser/
â”‚   â”‚   â”œâ”€â”€ parser.c              # FunÃ§Ã£o principal do parser: abre o arquivo e chama funÃ§Ãµes especÃ­ficas
â”‚   â”‚   â”œâ”€â”€ parser_utils.c        # FunÃ§Ãµes auxiliares para manipulaÃ§Ã£o de strings, validaÃ§Ã£o, split, etc.
â”‚   â”‚   â”œâ”€â”€ parse_ambient.c       # Parser para luz ambiente (A)
â”‚   â”‚   â”œâ”€â”€ parse_camera.c        # Parser para cÃ¢mera (C)
â”‚   â”‚   â”œâ”€â”€ parse_light.c         # Parser para luz pontual (L)
â”‚   â”‚   â”œâ”€â”€ parse_sphere.c        # Parser para esfera (sp)
â”‚   â”‚   â”œâ”€â”€ parse_plane.c         # Parser para plano (pl)
â”‚   â”‚   â”œâ”€â”€ parse_cylinder.c      # Parser para cilindro (cy)
â”‚   â”‚   â””â”€â”€ parser.h              # Prototypes e structs especÃ­ficas do parser
â”‚   â”‚
â”‚   â””â”€â”€ Makefile
â”‚
â””â”€â”€ README.md

```

===========================
Sprints de Desenvolvimento
===========================

---------------------------
Sprint 1: Tuplas e Vetores
---------------------------
- Implementar tuple.h/c:
    - FunÃ§Ãµes: point(), vector(), add(), sub(), negate(), scale()
               magnitude(), normalize(), dot(), cross()
- Criar testes com assert em test_runner.c

------------------------------
Sprint 2: Matrizes 4x4
------------------------------
- Implementar matrix.h/c:
    - FunÃ§Ãµes: identidade, multiplicaÃ§Ã£o, submatriz, cofator,
               determinante, inversa
    - MultiplicaÃ§Ã£o matriz Ã— tupla
- Criar testes para inversa e determinante

----------------------------------
Sprint 3: TransformaÃ§Ãµes
----------------------------------
- Implementar transforms.h/c:
    - FunÃ§Ãµes: translation, scaling, rotation_x, rotation_y,
               rotation_z, shearing
- Criar funÃ§Ã£o: multiply_transform_chain()
- Testar transformaÃ§Ãµes aplicadas em tuplas

-----------------------------------------
Sprint 4: Raios e InterseÃ§Ãµes
-----------------------------------------
- Implementar ray.h/c:
    - Criar raio, calcular ponto ao longo do raio (position)
- Implementar sphere.h/c:
    - Criar esfera, aplicar transformaÃ§Ãµes
- Implementar intersection.h/c:
    - FunÃ§Ãµes: intersect(), hit()

--------------------------------------
Sprint 5: Luz e Materiais
--------------------------------------
- Implementar light.h/c:
    - FunÃ§Ã£o: point_light
- Implementar material.h/c:
    - Propriedades: cor base, difuso, especular, shininess
- Implementar funÃ§Ã£o: lighting() (modelo Phong)

---------------------------------------
Sprint 6: CÃ¢mera e Canvas
---------------------------------------
- Implementar camera.h/c:
    - FunÃ§Ãµes: ray_for_pixel(), render()
- Implementar canvas.h/c:
    - Estrutura de pixels, exportaÃ§Ã£o .ppm
- Testar renderizaÃ§Ã£o de imagem simples

-----------------------------------------------------------
Sprint 7: Parser do Arquivo .rt e Estrutura de Cena (world)
-----------------------------------------------------------
- Implementar parser do arquivo .rt para:
    - Ambient (A)
    - Camera (C)
    - Light (L)
    - Objetos: Sphere (sp), Plane (pl), Cylinder (cy)
- Criar structs da cena (t_world):
    - Listas/arrays de objetos e luzes
- Validar e tratar erros do .rt:
    - Formato invÃ¡lido, valores fora do padrÃ£o
- Testar leitura de arquivos .rt reais

------------------------------------------------------
Sprint 8: Plano e Cilindro (Geometria AvanÃ§ada)
------------------------------------------------------
- Implementar interseÃ§Ã£o para Plano (pl)
- Implementar interseÃ§Ã£o e normais para Cilindro (cy):
    - Considerar altura, raio, tampas
- Suportar transformaÃ§Ãµes em todos os objetos
- Testar interseÃ§Ãµes e normais, inclusive internas

-----------------------------------------------
Sprint 9: IluminaÃ§Ã£o Completa e Sombras
-----------------------------------------------
- Completar modelo de iluminaÃ§Ã£o:
    - ambient, diffuse, specular
- Implementar detecÃ§Ã£o de sombras duras: is_shadowed()
- Aplicar sombras na renderizaÃ§Ã£o
- Testar configuraÃ§Ãµes variadas de luz e materiais

------------------------------------------------------
Sprint 10: IntegraÃ§Ã£o com MiniLibX (Janela GrÃ¡fica)
------------------------------------------------------
- Criar structs t_mlx e t_img
- Implementar conversÃ£o do canvas para imagem MLX
- Criar e exibir janela com MiniLibX
- Adicionar eventos:
    - Fechar com ESC ou botÃ£o de janela
- Garantir responsividade:
    - Minimizar, foco etc.
- Testar renderizaÃ§Ã£o final na janela interativa

---
===========================
FunÃ§Ãµes por Arquivo
===========================

---------------------------
tuple.h
---------------------------
t_tuple     new_tuple(float x, float y, float z, t_bool is_point);
t_tuple     add_tuple(t_tuple t1, t_tuple t2);
t_tuple     subtract_tuple(t_tuple t1, t_tuple t2);
t_tuple     multiply_tuple(t_tuple t, float scalar);
t_tuple     divide_tuple(t_tuple t, float scalar);

t_tuple     negate_tuple(t_tuple t);
t_tuple     normalize_vector(t_tuple t);
t_tuple     vector_cross(t_tuple t1, t_tuple t2);
t_tuple     vector_tuple(float x, float y, float z);
t_tuple     point_tuple(float x, float y, float z);

float       magnitude_vector(t_tuple t);
float       vector_dot(t_tuple t1, t_tuple t2);
int         tuple_equal(t_tuple t1, t_tuple t2);
double      get_tuple_value(t_tuple t, int index);
void        set_tuple_value(t_tuple *t, int index, double value);

---------------------------
matrix.h
---------------------------
t_matrix    identity_matrix(int size);
t_bool      equal_matrix(t_matrix m1, t_matrix m2);
t_matrix    matrix_multiply_by_matrix(t_matrix a, t_matrix b);
t_tuple     matrix_multiply_by_tuple(t_matrix m, t_tuple t);
t_matrix    transpose_matrix(t_matrix matrix);

t_matrix    submatrix(t_matrix matrix, int row, int col);
t_matrix    matrix_inverse(t_matrix matrix);
t_matrix    new_matrix(int rows, int cols);
int         matrix_determinant(t_matrix matrix);
int         matrix_minor(t_matrix matrix, int row, int col);

int         matrix_cofactor(t_matrix matrix, int row, int col);
int         matrix_is_invertible(t_matrix matrix);
int         matrix_determinant_2x2(t_matrix matrix);
void        print_matrix(t_matrix matrix);
void        free_matrix(t_matrix matrix);

---------------------------
transforms.h
---------------------------
t_matrix    translation(int size, float *data);
t_matrix    scaling(int size, float *data);
t_matrix    rotation_x(float r);
t_matrix    rotation_y(float r);
t_matrix    rotation_z(float r);
t_matrix    shearing(float xy, float xz, float yx, float yz, float zx, float zy);

---------------------------
ray.h
---------------------------
t_ray       ray(t_tuple origin, t_tuple direction);
t_tuple     position(t_ray r, float t);
t_ray       transform_ray(t_ray r, t_matrix m);

---------------------------
sphere.h
---------------------------
t_sphere    sphere(void);
void        set_transform(t_sphere *s, t_matrix t);
t_tuple     compute_normal(t_sphere *sphere, t_tuple point);

---------------------------
intersection.h
---------------------------
t_intersection *intersect(t_sphere *s, t_ray r, int *count);
t_intersection *hit(t_intersection *xs, int count);

---------------------------
light.h
---------------------------
t_light     point_light(t_tuple position, t_color intensity);

---------------------------
material.h
---------------------------
t_material  default_material(void);
t_color     lighting_diffuse_specular(t_material_light_params mlp, t_lighting_context ctx);
t_color     calculate_diffuse(t_material material, t_color effective_color, float light_dot_normal);
t_color     calculate_specular(t_material material, t_light light, t_tuple reflectv, t_tuple eyev);
t_color     lighting(t_material_light_params mlp, t_lighting_context ctx);

---------------------------
color.h
---------------------------
t_color     color(float r, float g, float b);
t_color     add_color(t_color c1, t_color c2);
t_color     subtract_color(t_color c1, t_color c2);
t_color     multiply_color_scalar(t_color c, float scalar);
t_color     multiply_color(t_color c1, t_color c2);
int         color_equal(t_color c1, t_color c2);

---------------------------
canvas.h
---------------------------
t_canvas    *new_canvas(int width, int height);
t_rgb       *pixel_at(t_canvas *canvas, int x, int y);
void        write_pixel(t_canvas *canvas, int x, int y, t_rgb color);
void        free_canvas(t_canvas *canvas);
void        fill_black_canvas(t_canvas *canvas);
void        canvas_to_ppm(t_canvas *canvas, const char *filename);
int         clamp(float v);

---------------------------
camera.h
---------------------------
t_ray       ray_for_pixel(t_camera c, int px, int py);
void        render(t_camera c, t_world w, t_canvas *canvas);

---------------------------
ray_tracer_core.h
---------------------------
t_color     shade_hit(t_world *world, t_intersection *hit, t_ray ray);
t_color     color_at(t_world *world, t_ray ray);
int         is_shadowed(t_world *world, t_tuple point);


---

## ðŸ”¨ CompilaÃ§Ã£o (Makefile)
```makefile
CC=gcc
CFLAGS=-Wall -Wextra -Iinclude
SRC=$(wildcard src/*.c)
OBJ=$(SRC:.c=.o)
EXEC=raytracer

default: $(EXEC)

$(EXEC): $(OBJ)
	$(CC) $(CFLAGS) -o $@ $^

clean:
	rm -f $(OBJ) $(EXEC)
```

---

Se quiser, posso continuar agora com o  ### Sprint 7: Parser do Arquivo .rt e Estrutura de Cena (world)
-----------------------------------------------------------
- Implementar parser do arquivo .rt para:
    - Ambient (A)
    - Camera (C)
    - Light (L)
    - Objetos: Sphere (sp), Plane (pl), Cylinder (cy)
- Criar structs da cena (t_world):
    - Listas/arrays de objetos e luzes
- Validar e tratar erros do .rt:
    - Formato invÃ¡lido, valores fora do padrÃ£o
- Testar leitura de arquivos .rt reais
 
 
 Quero que eu avance com isso
