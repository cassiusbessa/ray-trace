# ğŸ¯ Projeto: Ray Tracer em C (baseado em "The Ray Tracer Challenge" + minirt da Ecole 42)

---

## ğŸ“¦ Estrutura do Projeto

```text
raytracer_c/
include/
â”‚   â””â”€â”€ miniRT.h
â”‚
src/
â”œâ”€â”€ tuple/
â”‚   â”œâ”€â”€ tuple_core.c          # create_tuple, point, vector, color, is_point/is_vector
â”‚   â”œâ”€â”€ tuple_math.c          # add_tuples, subtract_tuples, negate_tuple, multiply_tuple, divide_tuple
â”‚   â”œâ”€â”€ tuple_vector.c        # magnitude, normalize, dot, cross
â”‚   â””â”€â”€ tuple_utils.c         # equal_tuples, is_zero_vector, is_unit_vector, is_nan, is_finite
â”‚
â”œâ”€â”€ matrix/
â”‚   â”œâ”€â”€ matrix_core.c         # new_matrix, identity_matrix, free_matrix, print_matrix, equal_matrix
â”‚   â”œâ”€â”€ matrix_math.c         # matrix_multiply_by_matrix, matrix_multiply_by_tuple, transpose_matrix, submatrix, minor
â”‚   â”œâ”€â”€ matrix_determinant.c  # matrix_determinant, matrix_determinant_2x2, matrix_cofactor, matrix_is_invertible
â”‚   â””â”€â”€ matrix_inverse.c      # matrix_inverse
â”‚
â”œâ”€â”€ transformations/
â”‚   â”œâ”€â”€ translation_scaling.c # translation, scaling
â”‚   â”œâ”€â”€ rotation.c            # rotation_x, rotation_y, rotation_z
â”‚   â””â”€â”€ shearing.c            # shearing
â”‚
â”œâ”€â”€ ray/
â”‚   â”œâ”€â”€ ray.c                 # create_ray, ray_position, transform_ray
â”‚   â”œâ”€â”€ sphere.c              # create_sphere, set_transform, get_transform, default_sphere
â”‚   â””â”€â”€ intersection.c        # create_intersection, intersect, hit, prepare_computations
â”‚
â”œâ”€â”€ lighting/
â”‚   â”œâ”€â”€ point_light.c         # create_point_light
â”‚   â”œâ”€â”€ default_material.c    # default_material, set_material_props
â”‚   â””â”€â”€ lighting.c            # lighting_calculation, is_shadowed, reflect
â”‚
â”œâ”€â”€ color/
â”‚   â”œâ”€â”€ color_utils_1.c       # create_color, color_add, color_subtract
â”‚   â””â”€â”€ color_utils_2.c       # color_multiply, hadamard_product, clamp_color

â”‚   â”œâ”€â”€ world.c
â”‚   â”œâ”€â”€ camera.c
â”‚   â”œâ”€â”€ canvas.c
â”‚   â””â”€â”€ material.c
â”‚
â”œâ”€â”€ tests/                      # Testes unitÃ¡rios
â”‚   â””â”€â”€ test_runner.c
â”‚
â”œâ”€â”€ scenes/                     # Cenas salvas
â”‚   â””â”€â”€ final_scene.c
â”‚
â”œâ”€â”€ images/                     # SaÃ­das .ppm
â”‚   â””â”€â”€ render.ppm
â”‚
â”œâ”€â”€ Makefile
â””â”€â”€ README.md
```

---

## ğŸ“‹ Sprints de Desenvolvimento (7 dias)

### ğŸ§© Sprint 1: Tuplas e Vetores
- [ ] `tuple.h/c`: `point()`, `vector()`, `add()`, `sub()`, `negate()`, `scale()`, `magnitude()`, `normalize()`, `dot()`, `cross()`
- [ ] Testes com `assert` em `test_runner.c`

### ğŸ§® Sprint 2: Matrizes 4x4
- [ ] `matrix.h/c`: identidade, multiplicaÃ§Ã£o, submatriz, cofator, determinante, inversa
- [ ] MultiplicaÃ§Ã£o com tupla
- [ ] Testes de inversa e determinante

### ğŸ”§ Sprint 3: TransformaÃ§Ãµes
- [ ] `transforms.h/c`: `translation`, `scaling`, `rotation_x/y/z`, `shearing`
- [ ] `multiply_transform_chain()`
- [ ] Testes aplicando transformaÃ§Ãµes em tuplas

### ğŸ“ Sprint 4: Raios e InterseÃ§Ãµes
- [ ] `ray.h/c`: criar raio, calcular ponto ao longo de raio
- [ ] `sphere.h/c`: criar esfera, aplicar transformaÃ§Ãµes
- [ ] `intersection.h/c`: `intersect()`, `hit()`

### ğŸ’¡ Sprint 5: Luz e Materiais
- [ ] `light.h/c`: `PointLight`
- [ ] `material.h/c`: cor base, difuso, especular, shininess
- [ ] `lighting()` usando modelo Phong

### ğŸ¥ Sprint 6: CÃ¢mera e Canvas
- [ ] `camera.h/c`: `ray_for_pixel`, `render`
- [ ] `canvas.h/c`: matriz de pixels, exportaÃ§Ã£o `.ppm`
- [ ] Teste de imagem simples

### ğŸŒ Sprint 7: Cena Final
- [ ] `world.h/c`: organizar cena, objetos e luzes
- [ ] `main.c`: montar cena completa
- [ ] Exportar `render.ppm`

---

## ğŸ“Œ FunÃ§Ãµes por Arquivo

### `tuple.h`
```c
typedef struct s_tuple { float x, y, z, w; } t_tuple;
t_tuple point(float x, float y, float z);
t_tuple vector(float x, float y, float z);
t_tuple add(t_tuple a, t_tuple b);
t_tuple sub(t_tuple a, t_tuple b);
t_tuple negate(t_tuple t);
t_tuple scale(t_tuple t, float s);
float magnitude(t_tuple t);
t_tuple normalize(t_tuple t);
float dot(t_tuple a, t_tuple b);
t_tuple cross(t_tuple a, t_tuple b);
```

### `matrix.h`
```c
typedef struct s_matrix { float m[4][4]; } t_matrix;
t_matrix identity_matrix();
t_matrix multiply_matrix(t_matrix a, t_matrix b);
t_tuple multiply_matrix_tuple(t_matrix m, t_tuple t);
t_matrix transpose(t_matrix m);
t_matrix inverse(t_matrix m);
float determinant(t_matrix m);
```

### `transforms.h`
```c
t_matrix translation(float x, float y, float z);
t_matrix scaling(float x, float y, float z);
t_matrix rotation_x(float r);
t_matrix rotation_y(float r);
t_matrix rotation_z(float r);
t_matrix shearing(float xy, float xz, float yx, float yz, float zx, float zy);
```

### `ray.h`
```c
typedef struct s_ray { t_tuple origin; t_tuple direction; } t_ray;
t_ray ray(t_tuple origin, t_tuple direction);
t_tuple position(t_ray r, float t);
t_ray transform_ray(t_ray r, t_matrix m);
```

### `sphere.h`
```c
typedef struct s_sphere { t_matrix transform; } t_sphere;
t_sphere sphere();
void set_transform(t_sphere *s, t_matrix t);
```

### `intersection.h`
```c
typedef struct s_intersection { float t; t_sphere *object; } t_intersection;
t_intersection *intersect(t_sphere *s, t_ray r, int *count);
t_intersection *hit(t_intersection *xs, int count);
```

### `color.h`
```c
typedef struct s_color { float r, g, b; } t_color;
t_color color(float r, float g, float b);
t_color add_color(t_color a, t_color b);
t_color mul_color(t_color a, float s);
t_color hadamard(t_color a, t_color b);
```

### `light.h`
```c
typedef struct s_light { t_tuple position; t_color intensity; } t_light;
t_light point_light(t_tuple position, t_color intensity);
```

### `material.h`
```c
typedef struct s_material {
  t_color color;
  float ambient;
  float diffuse;
  float specular;
  float shininess;
} t_material;

t_color lighting(t_material m, t_light l, t_tuple pos, t_tuple eyev, t_tuple normalv, int in_shadow);
```

### `camera.h`
```c
typedef struct s_camera {
  int hsize, vsize;
  float fov;
  t_matrix transform;
} t_camera;
t_ray ray_for_pixel(t_camera c, int px, int py);
void render(t_camera c, t_world w, t_canvas *canvas);
```

### `canvas.h`
```c
typedef struct s_canvas {
  int width, height;
  t_color *pixels;
} t_canvas;
t_canvas *create_canvas(int w, int h);
void write_pixel(t_canvas *c, int x, int y, t_color color);
void canvas_to_ppm(t_canvas *c, const char *filename);
```

### `main.c`
```c
// Monta a cena final com chÃ£o e esferas, aplica transformaÃ§Ãµes e renderiza
```

---

## âœ… Testes (em `tests/test_runner.c`)
Usar `assert()` em todos os mÃ³dulos com comparaÃ§Ãµes de tuplas, matrizes e cores.

---

## ğŸ”¨ CompilaÃ§Ã£o (Makefile)
```makefile
CC=gcc
CFLAGS=-Wall -Wextra -Iinclude
SRC=$(wildcard src/*.c)
OBJ=$(SRC:.c=.o)
EXEC=raytracer

default: $(EXEC)

$(EXEC): $(OBJ)
	$(CC) $(CFLAGS) -o $@ $^

clean:
	rm -f $(OBJ) $(EXEC)
```

---

Se quiser, posso continuar agora com o **Dia 5: implementaÃ§Ã£o completa de `### ğŸ’¡ Sprint 5: Luz e Materiais
- [ ] `light.h/c`: `PointLight`
- [ ] `material.h/c`: cor base, difuso, especular, shininess
- [ ] `lighting()` usando modelo Phong. Quer que eu avance com isso?
