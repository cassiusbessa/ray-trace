# ðŸŽ¯ Projeto: Ray Tracer em C (baseado em "The Ray Tracer Challenge" + minirt da Ecole 42)

---

## ðŸ“¦ Estrutura do Projeto

```

raytracer_c/
â”œâ”€â”€ include/
â”‚   â””â”€â”€ miniRT.h
â”‚
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ camera/                   # Tudo relacionado a gerar raios e manipular a cÃ¢mera
â”‚   â”‚   â”œâ”€â”€ camera_utils.c        # Futuras utilidades da cÃ¢mera
â”‚   â”‚   â”œâ”€â”€ ray_for_pixel.c       # FunÃ§Ã£o ray_for_pixel
â”‚   â”‚   â””â”€â”€ render.c              # FunÃ§Ã£o render (usa ray_for_pixel)
â”‚
â”‚   â”œâ”€â”€ canvas/                   # Tudo sobre imagem, pixels e exportaÃ§Ã£o
â”‚   â”‚   â”œâ”€â”€ canvas.c              # create_canvas, write_pixel
â”‚   â”‚   â”œâ”€â”€ canvas_export.c       # canvas_to_ppm, clamp
â”‚   â”‚   â””â”€â”€ canvas_utils.c        # FunÃ§Ãµes auxiliares para canvas
â”‚
â”‚   â”œâ”€â”€ color/
â”‚   â”‚   â”œâ”€â”€ color_utils_1.c       # create_color, color_add, color_subtract
â”‚   â”‚   â””â”€â”€ color_utils_2.c       # color_multiply, hadamard_product, clamp_color
â”‚
â”‚   â”œâ”€â”€ geometry/                 # LÃ³gica de interseÃ§Ã£o para objetos geomÃ©tricos
â”‚   â”‚   â”œâ”€â”€ intersect_cylinder.c  # intersect_cylinder, hit_caps, get_normal_cylinder
â”‚   â”‚   â””â”€â”€ intersect_plane.c     # intersect_plane, get_normal_plane
â”‚
â”‚   â”œâ”€â”€ lighting/
â”‚   â”‚   â”œâ”€â”€ default_material.c    # default_material, set_material_props
â”‚   â”‚   â”œâ”€â”€ lighting.c            # lighting_calculation, is_shadowed, reflect
â”‚   â”‚   â”œâ”€â”€ point_light.c         # create_point_light
â”‚   â”‚   â””â”€â”€ ray_tracer_core.c     # shade_hit, color_at, compute_normal, is_shadowed
â”‚
â”‚   â”œâ”€â”€ matrix/
â”‚   â”‚   â”œâ”€â”€ matrix_core.c         # new_matrix, identity_matrix, free_matrix, print_matrix, equal_matrix
â”‚   â”‚   â”œâ”€â”€ matrix_determinant.c  # matrix_determinant, matrix_determinant_2x2, matrix_cofactor, matrix_is_invertible
â”‚   â”‚   â”œâ”€â”€ matrix_inverse.c      # matrix_inverse
â”‚   â”‚   â””â”€â”€ matrix_math.c         # matrix_multiply_by_matrix, matrix_multiply_by_tuple, transpose_matrix, submatrix, minor
â”‚
â”‚   â”œâ”€â”€ parser/
â”‚   â”‚   â”œâ”€â”€ parse_ambient.c       # Parser para luz ambiente (A)
â”‚   â”‚   â”œâ”€â”€ parse_camera.c        # Parser para cÃ¢mera (C)
â”‚   â”‚   â”œâ”€â”€ parse_cylinder.c      # Parser para cilindro (cy)
â”‚   â”‚   â”œâ”€â”€ parse_light.c         # Parser para luz pontual (L)
â”‚   â”‚   â”œâ”€â”€ parse_plane.c         # Parser para plano (pl)
â”‚   â”‚   â”œâ”€â”€ parse_sphere.c        # Parser para esfera (sp)
â”‚   â”‚   â”œâ”€â”€ parser.c              # FunÃ§Ã£o principal do parser
â”‚   â”‚   â”œâ”€â”€ parser.h              # Prototypes e structs especÃ­ficas do parser
â”‚   â”‚   â”œâ”€â”€ parser_utils_1.c      # FunÃ§Ãµes auxiliares (split, validaÃ§Ã£o, etc.)
â”‚   â”‚   â””â”€â”€ parser_utils_2.c      # FunÃ§Ãµes auxiliares (validaÃ§Ã£o, conversÃ£o, etc.)
â”‚
â”‚   â”œâ”€â”€ ray/
â”‚   â”‚   â”œâ”€â”€ intersection.c        # create_intersection, intersect, hit, prepare_computations, etc.
â”‚   â”‚   â”œâ”€â”€ ray.c                 # create_ray, ray_position, transform_ray
â”‚   â”‚   â”œâ”€â”€ sphere.c              # create_sphere, set_transform, get_transform, default_sphere
â”‚   â”‚   â””â”€â”€ world.c               # intersect_world, lighting, etc. (se existir)
â”‚
â”‚   â”œâ”€â”€ transformations/
â”‚   â”‚   â”œâ”€â”€ rotation.c            # rotation_x, rotation_y, rotation_z
â”‚   â”‚   â”œâ”€â”€ shearing.c            # shearing
â”‚   â”‚   â””â”€â”€ translation_scaling.c # translation, scaling
â”‚
â”‚   â”œâ”€â”€ tuple/
â”‚   â”‚   â”œâ”€â”€ tuple_core.c          # create_tuple, point, vector, color, is_point/is_vector
â”‚   â”‚   â”œâ”€â”€ tuple_math.c          # add_tuples, subtract_tuples, negate_tuple, multiply_tuple, divide_tuple
â”‚   â”‚   â”œâ”€â”€ tuple_utils.c         # equal_tuples, is_zero_vector, is_unit_vector, is_nan, is_finite
â”‚   â”‚   â””â”€â”€ tuple_vector.c        # magnitude, normalize, dot, cross
â”‚
â”‚   â””â”€â”€ Makefile
â”‚
â””â”€â”€ README.md

```

===========================
Sprints de Desenvolvimento
===========================

---------------------------
Sprint 1: Tuplas e Vetores
---------------------------
- Implementar tuple.h/c:
    - FunÃ§Ãµes: point(), vector(), add(), sub(), negate(), scale()
               magnitude(), normalize(), dot(), cross()
- Criar testes com assert em test_runner.c

------------------------------
Sprint 2: Matrizes 4x4
------------------------------
- Implementar matrix.h/c:
    - FunÃ§Ãµes: identidade, multiplicaÃ§Ã£o, submatriz, cofator,
               determinante, inversa
    - MultiplicaÃ§Ã£o matriz Ã— tupla
- Criar testes para inversa e determinante

----------------------------------
Sprint 3: TransformaÃ§Ãµes
----------------------------------
- Implementar transforms.h/c:
    - FunÃ§Ãµes: translation, scaling, rotation_x, rotation_y,
               rotation_z, shearing
- Criar funÃ§Ã£o: multiply_transform_chain()
- Testar transformaÃ§Ãµes aplicadas em tuplas

-----------------------------------------
Sprint 4: Raios e InterseÃ§Ãµes
-----------------------------------------
- Implementar ray.h/c:
    - Criar raio, calcular ponto ao longo do raio (position)
- Implementar sphere.h/c:
    - Criar esfera, aplicar transformaÃ§Ãµes
- Implementar intersection.h/c:
    - FunÃ§Ãµes: intersect(), hit()

--------------------------------------
Sprint 5: Luz e Materiais
--------------------------------------
- Implementar light.h/c:
    - FunÃ§Ã£o: point_light
- Implementar material.h/c:
    - Propriedades: cor base, difuso, especular, shininess
- Implementar funÃ§Ã£o: lighting() (modelo Phong)

---------------------------------------
Sprint 6: CÃ¢mera e Canvas
---------------------------------------
- Implementar camera.h/c:
    - FunÃ§Ãµes: ray_for_pixel(), render()
- Implementar canvas.h/c:
    - Estrutura de pixels, exportaÃ§Ã£o .ppm
- Testar renderizaÃ§Ã£o de imagem simples

-----------------------------------------------------------
Sprint 7: Parser do Arquivo .rt e Estrutura de Cena (world)
-----------------------------------------------------------
- Implementar parser do arquivo .rt para:
    - Ambient (A)
    - Camera (C)
    - Light (L)
    - Objetos: Sphere (sp), Plane (pl), Cylinder (cy)
- Criar structs da cena (t_world):
    - Listas/arrays de objetos e luzes
- Validar e tratar erros do .rt:
    - Formato invÃ¡lido, valores fora do padrÃ£o
- Testar leitura de arquivos .rt reais

------------------------------------------------------
Sprint 8: Plano e Cilindro (Geometria AvanÃ§ada)
------------------------------------------------------
- Implementar interseÃ§Ã£o para Plano (pl)
- Implementar interseÃ§Ã£o e normais para Cilindro (cy):
    - Considerar altura, raio, tampas
- Suportar transformaÃ§Ãµes em todos os objetos
- Testar interseÃ§Ãµes e normais, inclusive internas

-----------------------------------------------
Sprint 9: IluminaÃ§Ã£o Completa e Sombras
-----------------------------------------------
- Completar modelo de iluminaÃ§Ã£o:
    - ambient, diffuse, specular
- Implementar detecÃ§Ã£o de sombras duras: is_shadowed()
- Aplicar sombras na renderizaÃ§Ã£o
- Testar configuraÃ§Ãµes variadas de luz e materiais

------------------------------------------------------
Sprint 10: IntegraÃ§Ã£o com MiniLibX (Janela GrÃ¡fica)
------------------------------------------------------
- Criar structs t_mlx e t_img
- Implementar conversÃ£o do canvas para imagem MLX
- Criar e exibir janela com MiniLibX
- Adicionar eventos:
    - Fechar com ESC ou botÃ£o de janela
- Garantir responsividade:
    - Minimizar, foco etc.
- Testar renderizaÃ§Ã£o final na janela interativa

---
===========================
FunÃ§Ãµes por Arquivo
===========================
// ----------------------
// Tuple functions
// ----------------------

t_tuple		new_tuple(float x, float y, float z, t_bool is_point);
t_tuple		add_tuple(t_tuple t1, t_tuple t2);
t_tuple		subtract_tuple(t_tuple t1, t_tuple t2);
t_tuple		multiply_tuple(t_tuple t, float scalar);
t_tuple		negate_tuple(t_tuple t);
t_tuple		divide_tuple(t_tuple t, float scalar);
t_tuple		normalize_vector(t_tuple t);
t_tuple		vector_cross(t_tuple t1, t_tuple t2);
t_tuple		vector_tuple(float x, float y, float z);
t_tuple		point_tuple(float x, float y, float z);

float		magnitude_vector(t_tuple t);
float		vector_dot(t_tuple t1, t_tuple t2);
int			tuple_equal(t_tuple t1, t_tuple t2);

double		get_tuple_value(t_tuple t, int index);
void		set_tuple_value(t_tuple *t, int index, double value);

// ----------------------
// Matrix functions
// ----------------------

t_matrix	identity_matrix(int size);
t_bool		equal_matrix(t_matrix m1, t_matrix m2);
t_matrix	matrix_multiply_by_matrix(t_matrix a, t_matrix b);
t_tuple		matrix_multiply_by_tuple(t_matrix m, t_tuple t);
t_matrix	transpose_matrix(t_matrix matrix);
t_matrix	submatrix(t_matrix matrix, int row, int col);
t_matrix	matrix_inverse(t_matrix matrix);
t_matrix	new_matrix(int rows, int cols);

int			matrix_determinant(t_matrix matrix);
int			matrix_minor(t_matrix matrix, int row, int col);
int			matrix_cofactor(t_matrix matrix, int row, int col);
int			matrix_is_invertible(t_matrix matrix);
int			matrix_determinant_2x2(t_matrix matrix);

void		print_matrix(t_matrix matrix);
void		free_matrix(t_matrix matrix);

// ----------------------
// Matrix transformations
// ----------------------

t_matrix	translation(int size, float *data);
t_matrix	scaling(int size, float *data);
t_matrix	rotation_x(float r);
t_matrix	rotation_y(float r);
t_matrix	rotation_z(float r);
t_matrix	shearing(float xy, float xz, float yx, float yz, float zx, float zy);
t_matrix	view_transform(t_tuple from, t_tuple to, t_tuple up);
t_matrix	translation_matrix(float tx, float ty, float tz);

// ----------------------
// Ray functions
// ----------------------

t_ray		ray(t_tuple origin, t_tuple direction);
t_tuple		position(t_ray r, float t);
t_ray		transform_ray(t_ray r, t_matrix m);

// ----------------------
// Sphere functions
// ----------------------

t_sphere	sphere(void);
void		set_transform(t_sphere *s, t_matrix t);

// ----------------------
// Intersection functions
// ----------------------

t_intersection	*intersect(t_sphere *s, t_ray r, int *count);
t_intersection	*hit(t_intersection *xs, int count);
int compare_intersections(const void *a, const void *b);
static t_intersection *resize_intersections(t_intersection *arr, int *capacity);
static int append_intersections(t_intersection **dst, int *total_count, int *capacity, t_intersection *src, int src_count);
t_intersection *intersect_world(t_world *world, t_ray ray, int *count);

// ----------------------
// Light and Material functions
// ----------------------

t_light		point_light(t_tuple position, t_color intensity);
t_material	default_material(void);
t_color		calculate_diffuse(t_material material, t_color effective_color, float light_dot_normal);
t_color		calculate_specular(t_material material, t_light light, t_tuple reflectv, t_tuple eyev);
t_color		lighting_diffuse_specular(t_material_light_params mlp, t_lighting_context ctx);
t_color		lighting(t_material_light_params mlp, t_lighting_context ctx);

// ----------------------
// Color functions
// ----------------------

t_color		color(float r, float g, float b);
t_color		add_color(t_color c1, t_color c2);
t_color		subtract_color(t_color c1, t_color c2);
t_color		multiply_color_scalar(t_color c, float scalar);
t_color		multiply_color(t_color c1, t_color c2);
int			color_equal(t_color c1, t_color c2);

// ----------------------
// Canvas functions
// ----------------------

void		free_canvas(t_canvas *canvas);
void		fill_black_canvas(t_canvas *canvas);
t_canvas	*new_canvas(int width, int height);
t_rgb		*pixel_at(t_canvas *canvas, int x, int y);
void		write_pixel(t_canvas *canvas, int x, int y, t_rgb color);
int			clamp(float v);
void		canvas_to_ppm(t_canvas *canvas, const char *filename);

// ----------------------
// Camera functions
// ----------------------

t_ray		ray_for_pixel(t_camera c, int px, int py);
void		render(t_camera c, t_world w, t_canvas *canvas);

// ----------------------
// Ray tracing core functions
// ----------------------

t_color		shade_hit(t_world *world, t_intersection *hit, t_ray ray);
t_color		color_at(t_world *world, t_ray ray);
t_tuple		compute_normal(t_sphere *sphere, t_tuple point);
int			is_shadowed(t_world *world, t_tuple point);

// ----------------------
// Parser functions
// ----------------------

int     parse_rt_file(const char *filename, t_world *world);
int     parse_ambient(const char *line, t_world *world);
int     parse_camera(const char *line, t_world *world);
int     parse_light(const char *line, t_world *world);
int     parse_sphere(const char *line, t_world *world);
int     parse_plane(const char *line, t_world *world);
int     parse_cylinder(const char *line, t_world *world);

int     line_is_empty_or_comment(const char *line);
int     starts_with(const char *line, const char *prefix);
void    free_split(char **tokens);
void    print_error(const char *msg);

void free_parsed_world(t_world *world, int should_free_world);
int     parse_vector(const char *str, t_tuple *out_vector);
int parse_point(const char *str, t_tuple *point);
int     parse_color(const char *str, t_color *out_color);
int     is_normalized(t_tuple v);
void add_object_to_world(t_world *world, t_object *new_object);
t_object *new_cylinder(t_tuple position, t_tuple orientation, float diameter, float height, t_color color);
t_object *create_sphere(t_tuple position, float diameter, t_color color);
t_object *create_plane(t_tuple position, t_tuple orientation, t_color color);
double  ft_atod(const char *nptr);
float   deg_to_rad(float degrees);


// ----------------------
// Geometry functions
// ----------------------

t_roots solve_quadratic(float a, float b, float c);
int is_within_cylinder_height(t_tuple point, t_cylinder c, t_tuple axis);
float intersect_cylinder(t_ray ray, t_cylinder c);
static float intersect_disk(t_ray ray, t_tuple center, t_tuple axis, float radius);
static float hit_caps(t_ray ray, t_cylinder c);
float cylinder_intersect(t_ray ray, t_cylinder c);
t_tuple get_normal_cylinder(t_cylinder c, t_tuple point);

t_vector get_normal_plane(t_plane plane);
t_tuple	get_normal_cylinder(t_cylinder c, t_tuple point);

---

## ðŸ”¨ CompilaÃ§Ã£o (Makefile)
```makefile
CC=gcc
CFLAGS=-Wall -Wextra -Iinclude
SRC=$(wildcard src/*.c)
OBJ=$(SRC:.c=.o)
EXEC=raytracer

default: $(EXEC)

$(EXEC): $(OBJ)
	$(CC) $(CFLAGS) -o $@ $^

clean:
	rm -f $(OBJ) $(EXEC)
```

---

Se quiser, posso continuar agora com o  ------------------------------------------------------
Sprint 8: Plano e Cilindro (Geometria AvanÃ§ada)
------------------------------------------------------
- Implementar interseÃ§Ã£o para Plano (pl)
- Implementar interseÃ§Ã£o e normais para Cilindro (cy):
    - Considerar altura, raio, tampas
- Suportar transformaÃ§Ãµes em todos os objetos
- Testar interseÃ§Ãµes e normais, inclusive internas

 
 
 Quero que eu avance com isso porem desejo que voc crie uma forma de me explicar com detalhes e me ensinar o que eu estou fazendo, se preocupe por cada detalhe e cada instruÃ§Ã£o na sprint 8, use todo conhecimento acima para conseguir essa tarefa
